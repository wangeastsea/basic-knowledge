<!-- https://time.geekbang.org/column/article/148546 -->
### 如何提升网络的速度

HTTP/1.1 为网络效率做了大量的优化，最核心的有如下三种方式：
- 增加了持久连接；
- 浏览器为每个域名最多同时维护 6 个 TCP 持久连接；
- 使用 CDN 的实现域名分片机制。


![image.png](https://upload-images.jianshu.io/upload_images/5016475-00a8c5a59c3d3f10.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)


如果使用单个 TCP 的持久连接，下载 100 个资源所花费的时间为 100 * n * RTT；

若通过上面的技术，就可以把整个时间缩短为 100 * n * RTT/(6 * CDN 个数)。从这个计算结果来看，我们的页面加载速度变快了不少。


#### http1.1 的主要问题
HTTP/1.1对带宽的利用率却并不理想

带宽是指每秒最大能发送或者接收的字节数。

我们把每秒能发送的最大字节数称为上行带宽

每秒能够接收的最大字节数称为下行带宽。

产生的原因： 
- 第一个原因，TCP 的慢启动。

    刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。

    之所以说慢启动会带来性能问题，是因为页面中常用的一些关键资源文件本来就不大，如 HTML 文件、CSS 文件和 JavaScript 文件，通常这些文件在 TCP 连接建立好之后就要发起请求的，但这个过程是慢启动，所以耗费的时间比正常的时间要多很多，这样就推迟了宝贵的首次渲染页面的时长了。

- 第二个原因，同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽

    系统同时建立了多条 TCP 连接，当带宽充足时，每条连接发送或者接收速度会慢慢向上增加；而一旦带宽不足时，这些 TCP 连接又会减慢发送或者接收的速度。比如一个页面有 200 个文件，使用了 3 个 CDN，那么加载该网页的时候就需要建立 6 * 3，也就是 18 个 TCP 连接来下载资源；在下载过程中，当发现带宽不足的时候，各个 TCP 连接就需要动态减慢接收数据的速度。

    这样就会出现一个问题，因为有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。

- 第三个原因，HTTP/1.1 队头阻塞的问题。

    我们知道在 HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着我们不能随意在一个管道中发送请求和接收内容。

    这是一个很严重的问题，因为阻塞请求的因素有很多，并且都是一些不确定性的因素，假如有的请求被阻塞了 5 秒，那么后续排队的请求都要延迟等待 5 秒，在这个等待的过程中，带宽、CPU 都被白白浪费了。

    在浏览器处理生成页面的过程中，是非常希望能提前接收到数据的，这样就可以对这些数据做预处理操作，比如提前接收到了图片，那么就可以提前进行编解码操作，等到需要使用该图片的时候，就可以直接给出处理后的数据了，这样能让用户感受到整体速度的提升。

    但队头阻塞使得这些数据不能并行请求，所以队头阻塞是很不利于浏览器优化的。

### http2 解决问题的方法 - 多路复用

总结下：HTTP/1.1 所存在的一些主要问题
- 慢启动和 TCP 连接之间相互竞争带宽是由于 TCP 本身的机制导致的
- 队头阻塞是由于 HTTP/1.1 的机制导致的

如何破局：

- HTTP/2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题

- 另外，就是队头阻塞的问题，等待请求完成后才能去请求下一个资源，这种方式无疑是最慢的，所以 HTTP/2 需要实现资源的并行请求，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。


**TTP/2 的解决方案可以总结为：一个域名只使用一个 TCP 长连接和消除队头阻塞问题。**


![image.png](https://upload-images.jianshu.io/upload_images/5016475-cc5f903d0f75c4d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

上图就是http2.0 最牛掰的多路复用机制

从图中你会发现每个请求都有一个对应的 ID，如 stream1 表示 index.html 的请求，stream2 表示 foo.css 的请求。这样在浏览器端，就可以随时将请求发送给服务器了。


HTTP/2 使用了多路复用技术，可以将请求分成一帧一帧的数据去传输，这样带来了一个额外的好处，就是当收到一个优先级高的请求时，比如接收到 JavaScript 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求。


#### 多路复用的实现
![image.png](https://upload-images.jianshu.io/upload_images/5016475-0662297bcfe0af2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

HTTP/2 添加了一个二进制分帧层
过程如下：
-  首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。

- 这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。

- 服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。

- 然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。

- 同样，二进制分帧层会将这些响应数据转换为一个个带有请求 ID 编号的帧，经过协议栈发送给浏览器。

- 浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。


通过引入二进制分帧层，就实现了 HTTP 的多路复用技术。

### http2的其他特性
我们知道了多路复用是 HTTP/2 的最核心功能，它能实现资源的并行传输。多路复用技术是建立在二进制分帧层的基础之上

- 设置请求的优先级
- 服务器推送

    除了设置请求的优先级外，HTTP/2 还可以直接将数据提前推送到浏览器。你可以想象这样一个场景，当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，这对首次打开页面的速度起到了至关重要的作用。

- 头部压缩

    无论是 HTTP/1.1 还是 HTTP/2，它们都有请求头和响应头，这是浏览器和服务器的通信语言。HTTP/2 对请求头和响应头进行了压缩，你可能觉得一个 HTTP 的头文件没有多大，压不压缩可能关系不大，但你这样想一下，在浏览器发送请求的时候，基本上都是发送 HTTP 请求头，很少有请求体的发送，通常情况下页面也有 100 个左右的资源，如果将这 100 个请求头的数据压缩为原来的 20%，那么传输效率肯定能得到大幅提升。


## 总结

分析了影响 HTTP/1.1 效率的三个主要因素：
- TCP 的慢启动、
- 多条 TCP 连接竞争带宽
- 队头阻塞。

HTTP/2 是如何采用多路复用机制来解决这些问题的。

多路复用是通过在协议栈中添加二进制分帧层来实现的，有了二进制分帧层还能够实现
- 请求的优先级
- 服务器推送
- 头部压缩等特性

从而大大提升了文件传输效率。

### http2 没有解决的问题
虽然 HTTP/2 解决了 HTTP/1.1 中的队头阻塞问题，但是 HTTP/2 依然是基于 TCP 协议的，而 TCP 协议依然存在数据包级别的队头阻塞问题，那么你觉得 TCP 的队头阻塞是如何影响到 HTTP/2 性能的呢？

是不管http/1我还是http/2，最后都需要经过tcp包的形式进行传输！

而tcp包也是按照顺序的，一个阻塞了，会影响到其它数据包的接受！