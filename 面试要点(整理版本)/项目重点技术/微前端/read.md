### 特点

- 独立运行、独立开发、独立部署
- 它能够使各个子系统进行数据共享。例如用户信息。
- 他能够对JS，css等进行相互隔离，防止出现污染问题。
- 它能够使各个子模块或者子系统进行隔离


### 目前有哪些方案：

#### 实现微前端的方案

1. 路由转发。当前的单页面应用的路由控制都是在前端进行。这就导致我们必须使用同一的技术栈，要不然`react-dom-router`他指挥不了vue路由，`vue-router`也指挥不了react。这也会导致我们的项目必须在一个同一的项目里进行开发，因为跨项目的话，就算技术栈一样，A也指挥不了B里面的路由跳转。但是如果我们将路由跳转交给服务端，当我们访问一个路由的时候，后端进行重定向等操作，这样就会将我们的应用`隔离`开。例如： `http://www.xxxx.com/a`与`http://wwww.xxxx.com/b`，当后端收到a路由的时候，指向一个系统，当收到b路由的时候指向另外一个系统，这样我的系统开发所采用的技术栈就可以进行隔离。如果要分享用户信息等，可以通过cookie等技术进行分享。因为每次路由匹配到的话，都会进行刷新，因此也防止了JS，css的污染问题

   >缺点：每次跳转都相当于重新刷新了一次页面，不是页面内进行跳转。影响体验。
   >
   >优点： 简单，可快速配置。

2. iframe嵌套。通过创建一个父程序，在父程序中监听路由的变化，卸载或加载相应的子程序iframe。因每一个iframe就相当于一个单独的页面，所以iframe具有天然的JS和css隔离。在信息共享方面，我们可以使用postMessage或者contentWindow的方式进行。

   > 缺点： iframe样式兼容问题。分别为功能性兼容性以及业务性兼容性的问题。可能会存在一些安全问题。postmessage可以试出来。
   >
   > - 主应用劫持快捷键操作
   > - 事件无法冒泡顶层，针对整个应用统一处理时效
   > - iframe 内元素会被限制在文档树中，视窗宽高限制问题
   > - 无法共享基础库进一步减少包体积
   > - 事件通信繁琐且限制多（https://blog.csdn.net/willspace/article/details/49003963）
   >
   > 优点：实现起来简单，自带沙盒特性

3. 纯[web components](https://www.ruanyifeng.com/blog/2019/08/web_components.html)开发。将每个子应用采用web components进行开发。纯web-components相当于自定义了一个html标签，我们就可以在任何的框架中进行使用此标签。例如：   

   > 优点： 每个子应用拥有独立的script和css，也可单独部署
   >
   > 缺点：需要对之前的子系统都要进行改造，并且通信方面较为复杂

   4. 组合式应用路由分发。每个子应用单独的打包，部署和运行。不过需要基于父应用进行路由管理。例如：有子应用A的路由是/testA，子应用B的路由是/testB，那么父应用在监听到/testA的时候，如果此时处于/testB，那么首先会进行一个子应用B的卸载。完成之后，在去加载子应用A。

   > 优点：纯前端改造，相比于路由式，无刷新，体验感良好。
   >
   > 缺点：需要解决样式冲突，JS污染问题，通信技术等。


#### 目前采用的方案

目前的微前端采用的技术方案是`组合式应用路由分发`。那么我们都知道，他的缺点是需要自行解决JS的沙盒环境、css的样式重叠或冲突问题、通信技术问题。

- css 冲突问题解决
    - 可以自定义前缀。在开发子模块之前，需要确定一个全局唯一的css前缀，然后在书写的过程中同一添加此前缀，或在根root上添加此前缀，使用less或sass作用域嵌套即可解。例如：

- JS的沙盒环境
    沙盒环境最主要做的就是一个js作用域、属性等的隔离。

    可以采用的方法：
        - diff方法。当我们的子页面加载到父类的基座中的时候，我们可以生成一个map的散列表。在页面渲染之前，我们先把当前的window上的变量等都存储在这个map中。当页面卸载的时候，我们在遍历这个map，将其数据在替换回去。
        - 使用代理的形式。在这里需要介绍一个es6的新特性：`proxy`，原理大致是，监听get和set方法，针对当前路由进行window的属性或方法的存取
        - iframe自带css和js沙盒隔离。


- single-spa的使用
    使用原理：
    - 注册子应用
    - 激活后自动去加载子应用的资源
    为什么需要乾坤：
        - 没有解决js沙盒环境
        - qiankun解决了沙盒环境
  
- 组合式应用路由分发的2种方案
    - JS entry
        JS Entry 的方式通常是子应用将资源打成一个 entry script，但这个方案的限制也颇多，如要求子应用的所有资源打包到一个 js bundle 里，包括 css、图片等资源。除了打出来的包可能体积庞大之外的问题之外，资源的并行加载等特性也无法利用上,前端性能低下
    - html entry
        HTML Entry 则更加灵活，直接将子应用打出来 HTML 作为入口，主框架可以通过 fetch html 的方式获取子应用的静态资源，同时将 HTML document 作为子节点塞到主框架的容器中。这样不仅可以极大的减少主应用的接入成本，子应用的开发方式及打包方式基本上也不需要调整，而且可以天然的解决子应用之间样式隔离的问题(后面提到)。

- sigle-spa的实现原理

- webpack5 Module federation
    是啥：
    ​ 例如我们有一个项目a，要使用项目b中的某些功能。对于npm的形式，我们可以通过将b的项目打包之后，让项目a引用就行。假设这个时候突然项目b发现自己的写的某些功能有bug，那么也要项目a更新依赖包重新发布。如果是mf的形式，我们就只需要更新项目b即可。这是最大的区别。
    原理：
        - 加载其他应用的组件通过mf打包后暴露出来的文件remoteEntry.js
        - 执行remoteEntry.js，在全局作用域下挂载一个名为在mf中定义的name的属性，这个属性暴露了get和override这两个方法
        - 在组件中引用的时候，会通过__webpack_require__.e去进行引用。
        - __webpack_require__.e中调用__webpack_require__.f中的对应的方法，从而得到相应的组件。

- Module federation与qiankun以及single-spa的区别

共同点： 都能实现微前端
不同点：
- qiankun与single-spa是基于应用的，而mf是基于组件的。
- mf对于无限套娃模式支持比较友好，
- mf对于老项目不太友好，需要升级对应的webpack，不能直接使用.html文件。
- 与single-spa一样，不支持js沙盒环境，需要自己进行实现。
- 第一次需要将引用的依赖前置，会导致加载时间变成的问题。

