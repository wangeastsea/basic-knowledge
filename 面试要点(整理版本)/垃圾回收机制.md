参考：https://time.geekbang.org/column/article/131233


### 栈 的内存回收
栈中的垃圾回收是通过，ESP指针往下移动，来回收栈的内存。就是当另一块函数入栈时，会覆盖这一块需要把回收的栈空间。

### 堆的内存回收
要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了。

#### 重要概念
代际假说和分代收集

代际假说有以下两个特点：
- 第一个是大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问；
- 第二个是不死的对象，会活得更久。

通常，垃圾回收算法有很多种，但是并没有哪一种能胜任所有的场景，你需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果。
在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。

- 副垃圾回收器，主要负责新生代的垃圾回收。
- 主垃圾回收器，主要负责老生代的垃圾回收。

### Js中的垃圾回收机制

垃圾回收算法主要依赖于引⽤用的概念。

在内存管理理的环境中，一个对象如果有访问另⼀个对象的权限（隐式或者显式），叫做⼀个对象引⽤用另⼀个对象。例如，一个Javascript对象具有对它原型的引⽤（隐式引⽤用）和对它属性的引⽤显式引用）。在这⾥，“对象”的概念不仅特指 JavaScript 对象，还包括函数作⽤域（或者全局词法作用域）

#### 引用记数垃圾回收

引用计数算法定义“内存不再使用”的标准很简单，就是看⼀个对象是否有指向它的引⽤。如果没有其他对象指向它了，说明该对象已经不再需了了

但它却存在⼀一个致命的问题：循环引⽤

如果两个对象相互引用，尽管他们已不再使⽤用，垃圾回收不会进⾏回收，导致内存泄露

#### 标记清除

标记清除算法将“不再使⽤的对象”定义为“⽆法达到的对象”。简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使⽤的。那些⽆法由根部出发触及到的对象，稍后进行回收。


  - 垃圾收集器器在运⾏的时候会给存储在内存中的所有变量都加上标记。    
  - 从根部出发将能触及到的对象的标记清除。    
  - 那些还存在标记的变量被视为准备删除的变量。    
  - 最后垃圾收集器会执⾏最后⼀步内存清除的⼯作，销毁那些带标记的值并回收它们所占⽤的内存空间。


  #### 常见的内存泄漏

  - 全局变量
  ```js
  functionfoo () {
        bar1 = ‘some text’;// 没有声明变量量实际上是全局变量量 => window.bar1
        this.bar2 = ‘some text’ // 全局变量量 => window.bar2
    }
    foo();
  ```

  - 未被清理的定时器和回调函数
  - 闭包
  - DOM引用

  #### 如何避免内存泄漏

  - 减少不必要的全局变量
  - 使用完数据，及时的解除引用（闭包的变量，dom引用，定时器清除）
